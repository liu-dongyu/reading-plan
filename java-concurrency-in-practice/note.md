## 第一章 简介

### 并发简史

* 早期计算机单次只能执行一个程序，能访问计算机的所有资源。在这种情况下，很难运行和编写程序，也浪费昂贵的计算机资源
* 操作系统诞生后，计算机能同时运行多个程序，不同的程序都在单独的进程中运行，操作系统为进程分配资源，例如内存。不同进程间可以通过通信机制交换数据
* 进程诞生的因素同样促使了线程的诞生，线程允许同一个进程内拥有多个不同的程序控制流，这些程序共享进程内资源
* 线程被称为轻量级的进程，在大多数现代操作系统中，都是以线程为调度单位

### 线程的优势

##### 发挥多处理器的威力

* 在双处理器系统上，单线程的程序只能使用 50%的 CPU 资源，在拥有 100 处理器的系统上，99%的资源都无法使用
* 多线程程序能同时在多个处理器的运行，提高资源利用来提升系统的吞吐率
* 多线程程序可以在执行阻塞操作期间同步进行其他操作，而单线程程序在此期间只能等待

##### 建模的简单性

* 执行多类型任务时，（例如修 bug、面试、绩效考核），需要更多的考虑任务优先级和执行时间顺序等，时间管理不如只执行一种类型任务简单
* 对软件来说同样如此，一个程序只包含一种类型的任务，更加容易编写维护和测试。如果为每种不同类型的任务分配一个专门的线程，将逻辑和资源调用分开（I/O 操作等），可以实现将复杂且异步的工作流分为一组组简单且同步的工作流

##### 异步事件的简化处理

* 在单线程应用程序中，同步 I/O 等操作会阻塞进程，终止其他响应，要避免这种问题，以往只能使用非阻塞 I/O，但这种 I/O 逻辑复杂，并且容易出错。在多线程应用程序中则不会有这个问题，通过分配单独线程，可以轻松使用同步 I/O 而不用担心会引起阻塞

##### 响应更灵敏的用户界面

* 传统 GUI 应用程序都是单线程的，当代码执行之间过长，例如大量的循环，读取文件，等待请求响应等，会照成用户界面停滞无法操作，需等待代码执行完毕才能继续操作
* 现代 GUI 应用程序采用时间分发线程，通过线程来调用页面事件处理器，这样就不用担心页面被冻结无法操作

### 线程的风险

##### 安全性问题

* 由于线程共享进程内的资源，所以线程极有可能会访问或修改别的线程正在使用的变量，这种并发安全问题称为竞态条件（Race Condition）,在多线程环境下，某个方法是否会返回唯一值，要取决于运行时线程的交替执行方案，然而这并不是开发者想要看到的
* java 提供了很多协同机制来避免并发安全问题，后面的章节会涉及

##### 活跃性问题

* 当线程中的某个操作无法继续下去，就会导致活跃性问题，例如线程 a 正在等待线程 b 释放资源，而线程 b 永远都不释放，那么线程 a 就会永远等待
* 死锁，饥饿等就是活跃性问题，后面的章节会涉及

##### 性能问题

* 安全性或活跃性问题都会带来资源浪费，无法释放等问题
* 在涉及优良的多线程应用中，线程调度器挂起活跃线程转向别的线程时，就会频繁出现上下文切换操作，该操作会带来极大的开销
* 当不同线程需要共享数据时，就需要同步机制，而这些机制会压制某些编译器优化，使得内存共享区的数据无效，以及增加共享内存总线的同步流量

---

...
