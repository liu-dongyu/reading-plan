## 第一章 简介

### 并发简史

* 早期计算机单次只能执行一个程序，能访问计算机的所有资源。在这种情况下，很难运行和编写程序，也浪费昂贵的计算机资源
* 操作系统诞生后，计算机能同时运行多个程序，不同的程序都在单独的进程中运行，操作系统为进程分配资源，例如内存。不同进程间可以通过通信机制交换数据
* 进程诞生的因素同样促使了线程的诞生，线程允许同一个进程内拥有多个不同的程序控制流，这些程序共享进程内资源
* 线程被称为轻量级的进程，在大多数现代操作系统中，都是以线程为调度单位

### 线程的优势

##### 发挥多处理器的威力

* 在双处理器系统上，单线程的程序只能使用 50%的 CPU 资源，在拥有 100 处理器的系统上，99%的资源都无法使用
* 多线程程序能同时在多个处理器的运行，提高资源利用来提升系统的吞吐率
* 多线程程序可以在执行阻塞操作期间同步进行其他操作，而单线程程序在此期间只能等待

##### 建模的简单性

* 执行多类型任务时，（例如修 bug、面试、绩效考核），需要更多的考虑任务优先级和执行时间顺序等，时间管理不如只执行一种类型任务简单
* 对软件来说同样如此，一个程序只包含一种类型的任务，更加容易编写维护和测试。如果为每种不同类型的任务分配一个专门的线程，将逻辑和资源调用分开（I/O 操作等），可以实现将复杂且异步的工作流分为一组组简单且同步的工作流

##### 异步事件的简化处理

* 在单线程应用程序中，同步 I/O 等操作会阻塞进程，终止其他响应，要避免这种问题，以往只能使用非阻塞 I/O，但这种 I/O 逻辑复杂，并且容易出错。在多线程应用程序中则不会有这个问题，通过分配单独线程，可以轻松使用同步 I/O 而不用担心会引起阻塞

##### 响应更灵敏的用户界面

* 传统 GUI 应用程序都是单线程的，当代码执行之间过长，例如大量的循环，读取文件，等待请求响应等，会照成用户界面停滞无法操作，需等待代码执行完毕才能继续操作
* 现代 GUI 应用程序采用时间分发线程，通过线程来调用页面事件处理器，这样就不用担心页面被冻结无法操作

### 线程的风险

##### 安全性问题

* 由于线程共享进程内的资源，所以线程极有可能会访问或修改别的线程正在使用的变量，这种并发安全问题称为竞态条件（Race Condition）,在多线程环境下，某个方法是否会返回唯一值，要取决于运行时线程的交替执行方案，然而这并不是开发者想要看到的
* java 提供了很多协同机制来避免并发安全问题，后面的章节会涉及

##### 活跃性问题

* 当线程中的某个操作无法继续下去，就会导致活跃性问题，例如线程 a 正在等待线程 b 释放资源，而线程 b 永远都不释放，那么线程 a 就会永远等待
* 死锁，饥饿等就是活跃性问题，后面的章节会涉及

##### 性能问题

* 安全性或活跃性问题都会带来资源浪费，无法释放等问题
* 在涉及优良的多线程应用中，线程调度器挂起活跃线程转向别的线程时，就会频繁出现上下文切换操作，该操作会带来极大的开销
* 当不同线程需要共享数据时，就需要同步机制，而这些机制会压制某些编译器优化，使得内存共享区的数据无效，以及增加共享内存总线的同步流量

---

## 第二章 线程安全性

* 要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是共享的（被多个线程同时访问）和可变的（在其生命周期内可以发生变化）状态
* 需要采用同步机制来对对象进行访问，才能确保对象是线程安全。不需要被多个线程同时访问则不需要线程安全
* java 主要的同步机制是 synchronized，它提供了一种独占对象的加锁方式
* 线程安全性不存在例外情况，哪怕程序目前使用正常，错误也只是早晚的事。当面对没有同步机制而出现的线程安全问题时，有 3 种方法可以尝试修复
  1. 不在线程中共享该状态变量
  2. 将改状态变量改为不可改变
  3. 在访问状态变量时使用同步

### 什么是线程安全性

*  当多个或单一线程访问某个类时，这个类始终都能表现出正确的行为，那么就称该类是线程安全的。由于无法保证类在编写完成之后都按照设想去运行，所以"代码可信度"就比较接近"正确的行为"
* 无状态对象一定是线程安全的

### 原子性

* 原子性：存在 A、B 两个操作，对于执行 A 操作的线程来说，当另外一个线程执行 B 操作，要么不执行，要么全部执行完。那么 A 和 B 对彼此来说是原子的
* 原子操作：访问状态的操作不可分割，以一种原子的形式进行

```java
// NoThreadSafe
class UnsafeCounting {
  private long count = 0;

  public long getCount() {
    return count;
  }

  public void addCount() {
    Thread.sleep(1000);
    ++count;
  }
}
```

* `++count`虽然看上去像是一个操作，但其实该操作并非原子的，实际上包含了读取、修改以及写入三种操作，结果状态依赖于之前的状态。所以当多个线程同步访问时，有可能会导致计算不准确

#### 竞态条件

* 当某个计算的正确性取决于多个线程的交替执行时序时，就会发生竞态条件
* 最典型的竞态条件就是“先检查后执行”，例如先检查文件 x 是否存在，不存在则执行创建文件 x 操作，但在检查之后与开始执行之前，有可能别的线程已经创建了文件 x，导致之前的检查结果无效，该情况下有可能导致数据覆盖、文件异常等 bug
* 基于对象之前的状态来定义对象状态的转化也是一种竞态条件，例如`++count`
* 并不是所有竞态条件都一定会产生错误，还需要某种不恰当的执行时序

#### “先检查后执行”的常见情况：延迟初始化

* 延迟初始化的目的是将对象初始化操作推迟到实际使用时才进行，同时确保只被初始化一次

```java
@NoThreadSafe
class unsafeLazyInit() {
  private SomeClass instance = null;

  public SomeClass getInstance() {
    if (instance == null) {
      instance = new SomeClass();
    }
    return instance;
  }
}
```

* 上述代码中，假如线程 A、B 同时执行`getInstance`，A、B 都需要判断`instance`是否为空，那么条件执行语句就要取决于不可预测的时序，例如调度器的执行方式、A 初始化`instance`并设置的时间，也就是说多次调用`getInstance`有可能返回不同结果

#### 复合操作

* 复合操作：包含一组以原子方式执行的操作以确保线程安全的操作，例如"读取、修改、写入"

```java
import java.util.concurrent.atomic.*;

// ThreadSafe
public class Demo {
  private static AtomicLong count = new AtomicLong(0);

  public static void main(String[] args) {
    System.out.println(count.incrementAndGet());
  }
}
```

* 如上述代码所示，`java.util.concurrent.atomic`包中提供了一些原子变量类，可以确保访问操作都是原子的

### 加锁机制

* 要保证状态的一致性，就需要在单个原子操作中更新所有的状态变量

#### 内置锁

```java
// ThreadSafe
public class Demo {
  private static long count = 0;

  synchronized void add() {
    ++count;
  }

  void add1() {
    synchronized (this) {
      ++count;
    }
  }

  public static void main(String[] args) {
    Demo demo = new Demo();
    demo.add();
    demo.add1();
    System.out.println(count); // 2
  }
}
```

* 如上述代码所示，`synchronized`是 java 提供的内置互斥锁，保证代码块内的操作都是原子的。使用内置锁确实可以保证线程安全，但也会带来性能问题（并发性差），毕竟同一时间只有一个线程能持有该锁

#### 重入

* 内置锁操作的粒度是“线程”而不是“调用”，所用某个线程试图获取一个已经有自己持有的锁不会产生死锁
* 子类可以重写并调用父类的持有锁的方法

```java
class father {
  synchronized void doSomething() {}
}

class child extends father {
  synchronized void doSomething() {
    super.doSomething();
  }
}
```

### 用锁来保护状态

* 对于可能被多个线程同时访问的可变状态变量，在访问他时，都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的
* 每个共享的可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁
* 一种常见的加锁方式是：将所有可变的状态都封装在对象内部，并通过内置锁对所有访问可变状态的代码路径进行同步，确保该对象上不会发生并发访问
* 并非所有数据都需要锁，只有被多个线程同时访问的可变数据才需要用锁来保护
* 当执行时间较长的计算或者可能无法快速完成的操作时（例如 I/O），一定不要持有锁

---

## 第三章 对象的共享

### 3.1 可见性

* 当某个状态的读操作和写操作在不同线程中执行，通常是无法确保读操作的线程能够实时看到别的线程写入的值，为了确保多个线程之间对内存写入操作的可见性，必须要有同步机制
* 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺行进行一些意想不到的调整。在缺乏足够同步的多线程程序中，无法对内存操作的执行顺序进行判断

#### 3.1.1 失效数据

* 当线程读取一个别的线程正在修改的数据时，在缺乏同步的情况下，读到的有可能是失效数据，操作失效数据有可能带来严重的安全性问题和活跃性问题

#### 3.1.2 非原子的 64 位操作

* 最低安全性要求，失效数据是某个线程之前设定的值，而不是随机值
* java 内存建模要求，变量的读取和写入操作都必须原子的。但对于非 volatile 类型的 64 位数值变量（double 和 long），jvm 允许将读和写操作分解为两个 32 位的操作，所以有可能会读到不同值的 32 位数据，导致达不到最低安全性要求

#### 3.1.3 加锁与可见性

...
