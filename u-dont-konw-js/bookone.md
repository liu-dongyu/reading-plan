## 第一章 作用域是什么

> 一种用于储存和获取变量的规则

### 编译原理

1. 传统编译语言流程如下
   1. 分词/词法分析
      * 将字符串分解成有意义的代码块，称为词法单元
      * 分词和词法分析主要差异在于词法单元的识别是通过有状态还是无状态的方式进行，例如`a`属于词法单元且同时属于其他词法单元的一部分，调用的是用状态的的解析规则，称为词法分析
      * 例如`var a = 2;`，会被分解为`var` `a` `=` `2` `;`，空格是否作为词法单元取决与在这门语言中时候有意义
   2. 解析/语法分析
      * 将词法单元流（数组）转化为一个由元素逐级潜逃组成的程序语法结构树，称为抽象语法树（abstract syntax tree AST）
      * `var a = 2;`的 AST 如右图<img src="./img/AST.jpeg" width="300" />
   3. 代码生成
      * 将`var a = 2;`的 AST 转化为机器指令
2. js 属于编译语言，但和传统的不一样，js 不是提前编译的，编译结果也不能运行在分布式系统中
3. js 会在语法分析和代码生成阶段拥有特殊的步骤对对运行性能以及冗余元素进行优化
4. 任何 js 代码运行前都需要编译， 编译需要几微秒（甚至更短）

### 理解作用域

#### 相关介绍

* 引擎：负责整个 js 的编译和执行
* 编译器：负责语法分析和代码生成等
* 作用域：负责收集和维护所有声明的变量组成的一些列查询，并实施一套严格的规则，确定当前代码对这些变量的访问权限

#### 赋值操作

`var a = 2;`，变量的赋值操作一般会执行两个动作

* 编译器在当前作用域新建一个变量（如果之前没有）
* 运行过程中，引擎会在作用域中寻找 a 变量，并赋值为 2，若没有找到则会抛出异常

#### 引擎如何执行查找

* 引擎在查找过程中会执行 LHS 或 RHS 查询，RHS 与简单查找某个变量的值一样，LHS 则是查找值的容器。L 和 R 代表左和右，意味着赋值操作的左边和右边，赋值操作并不单指`=`
* `console.log(a);`，由于`a`没有任何赋值，所以这里执行的是 RHS 查询，查找`a`对应的值
* `var a = 2;`，这里执行 LHS 查询， 需要先找到变量`a`才能用于`= 2`赋值

```javascript
/**
 * 1. c = .. LHS
 * 2. foo(2) RHS
 * 3. foo(a) -> a = 2 LHS
 * 4. b = a，对b进行LHS，对a进行RHS
 * 4. a + b，对a进行RHS，对b进行RHS
 */

function foo(a) {
  var b = a;
  return a + b;
}
var c = foo(2);
```

#### 作用域嵌套

当一个块或函数嵌套在另外一个块或函数中，就触发作用域嵌套，在当前作用域无法找到某个变量时，引擎会在嵌套的外层作用域继续寻找，直到全局作用域，而后无论是否找到，整个过程都会终止

#### 异常

* 找不到变量时,LHS 会在全局作用域创建一个变量（严格模式下会抛出 ReferenceError）
* 找不到变量时,RHS 则会抛出 ReferenceError 异常
* 如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或者引用`null`或`undefined`类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError
* ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。

---

## 第二章 词法作用域

### 定义

词法作用域就是定义在词法阶段的作用域，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变(大部分情况下是这样的)。没有任何作用域能同时出现在两个外部作用域中。

<img src="./img/demo.jpeg" width="300" />

* 1 包含着整个全局作用域，其中只有一个标识符:foo。
* 2 包含着 foo 所创建的作用域，其中有三个标识符:a、bar 和 b。
* 3 包含着 bar 所创建的作用域，其中只有一个标识符:c。

### 查找

* 作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置。
* 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，内部的标识符会遮蔽外部的标识符。
* 词法作用域查找只会查找一级标识符，比如 a、b 和 c。如果代码中引用了 foo.bar.baz，词法作用域查找只会试图查找 foo，找到后，对象属性访问规则会分别接管对 bar 和 baz 属性的访问

### 欺骗词法

```javascript
function foo(str, a) {
  // 引擎会认为由eval动态插入的代码书写时就在这
  eval(str);
  console.log(a, b); // 1, 3
}
var b = 2;
foo('var b = 3;', 1);
```

```javascript
function foo(obj) {
  // 实际上c不会存在于with的作用域内，而是会在foo内
  with (obj) {
    var c = 1;
    a = 2;
  }
}
var o1 = {
  a: 3,
};
var o2 = {
  b: 3,
};
foo(o1);
foo(o2);

// 将 o1 传递进去，a = 2 赋值操作找到了 o1.a 并将 2 赋值给它
console.log(o1.a);

// o2 传递进去，o2 并没有 a 属性，因此不会被创建，所以log出undefined
console.log(o2.a);

// a = 2 执行了 LHS 查询，在内部作用域到顶层作用域都找不到这个值，所以会在全局作用域新建
console.log(a);
```

* `eval`和`with`会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。
* 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。
* 如果代码中存在`eval`或`with`，引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢

---

## 第三章 函数作用域和块作用域

### 函数作用域

#### 含义

属于这个函数的全部变量都能在整个函数的范围或嵌套函数内使用以及复用。无法从外部作用域访问函数作用域内的变量

#### 隐藏内部实现

* 可以用一个函数将一段代码包装起来，从而将里面的变量和函数等从外部作用域中隐藏起来。这种做法称为最小特权（最小授权或最小暴露原则），这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。
* 可以避免变量或函数名冲突
* 通常第三方库会在全局全局作用域使用一个变量，例如`var myLib = {};`，`myLib`被称为命名空间，第三方库会隐藏自身的变量而将命名空间暴露给全局作用域，
* 规避冲突的另外一种方式是使用模块管理`import export`等，在需要的地方显示的引入特定作用域中，而不需要污染全局作用域

#### 函数表达式

将代码用函数包裹起来固然可以隐藏一些东西，但至少函数名会污染外部作用域。函数有两个，函数声明和函数表达式，`function`不是出现在整个声明代码的第一位置就是函数表达式，反之则为函数声明

```javascript
// 函数声明，test会暴露在外部作用域中
function test() {}

// 函数表达式，test只会存在于...的作用域中
var a = function test { ... }

// 我也是函数表达式
settimeout(function() {}, 0);

// 立即执行函数(IIFE)，也是函数表达式的一种，主要有两种用于
// 1. 自动执行 2. 颠倒代码运行的顺序，将需要运行的函数放在第二位，在 IIFE 执行之后当作参数传递进去
(function(global) ())(window)
```

函数表达式可以匿名也可具名，好的实践应该为所有函数表达式添加名称

* 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
* 没有函数名，很难在递归调用中使用自己。
* 匿名函数省略了对于代码可读性/可理解性很重要的函数名。

### 块作用域

在 es5 中，javascript 的块级作用域不清晰，很难实现你想要的样子

```javascript
var bar = true;
if (bar) {
  var a = 1;
}
```

如上代码，我们希望将`a`封死在`{}`块级作用域中，表面上看起来是这样，然而实际`var`存在变量提升问题（这里不详细谈论这个问题），无论在哪声明，都会出现在外部作用域中，es5 中能实现块级作用域的只有`with` `try()catch(err){// err变量只在这里有效}`

```javascript
var bar = true;
if (bar) {
  {
    const b = 1;
    let a = 1;
  }
}
```

如上代码，在 es6 中，可以定义`let`以及显示的块级作用域`{}`，以`let`声明的变量就不会存在于外部作用域中，只在当前块级作用域。`const`也可以用来定义块级作用域，但`const`的内容一经声明，不可以再改变。块级作用域的变量会在使用过后被垃圾回收
